{
    "sourceFile": "src/firebase/firebaseService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1738038751717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1738039103268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,8 +64,33 @@\n     return [];\n   }\n };\n \n+export const checkExistingShop = async (userId) => {\n+  try {\n+    const shopRef = doc(db, 'shops', userId);\n+    const shopDoc = await getDoc(shopRef);\n+    return shopDoc.exists();\n+  } catch (error) {\n+    console.error('Error checking existing shop:', error);\n+    throw error;\n+  }\n+};\n+\n+// Update saveShopData to check first\n+export const saveShopData = async (userId, data) => {\n+  try {\n+    const hasShop = await checkExistingShop(userId);\n+    if (hasShop) {\n+      throw new Error('User already has a shop');\n+    }\n+    // ... rest of the existing saveShopData code\n+  } catch (error) {\n+    console.error('Error in saveShopData:', error);\n+    throw error;\n+  }\n+};\n+\n // Add this utility function to clean data before saving to Firestore\n const cleanDataForFirestore = (data) => {\n   if (!data) return data;\n   \n"
                },
                {
                    "date": 1738039688171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,22 +75,8 @@\n     throw error;\n   }\n };\n \n-// Update saveShopData to check first\n-export const saveShopData = async (userId, data) => {\n-  try {\n-    const hasShop = await checkExistingShop(userId);\n-    if (hasShop) {\n-      throw new Error('User already has a shop');\n-    }\n-    // ... rest of the existing saveShopData code\n-  } catch (error) {\n-    console.error('Error in saveShopData:', error);\n-    throw error;\n-  }\n-};\n-\n // Add this utility function to clean data before saving to Firestore\n const cleanDataForFirestore = (data) => {\n   if (!data) return data;\n   \n@@ -138,97 +124,106 @@\n };\n \n export const saveShopData = async (userId, data) => {\n   try {\n-    console.log('Starting shop data save:', { userId, data });\n-    \n-    // Clean data before saving to Firestore\n-    let shopData = {\n-      name: data.name || '',\n-      description: data.description || '',\n-      theme: cleanDataForFirestore(data.theme) || {},\n-      layout: cleanDataForFirestore(data.layout) || {},\n-      createdAt: new Date().toISOString(),\n-      updatedAt: new Date().toISOString(),\n-      userId: userId,\n-      items: data.items?.map(item => ({\n-        id: item.id || Date.now().toString(),\n-        name: item.name || '',\n-        price: item.price || '',\n-        description: item.description || '',\n-        currentImageIndex: item.currentImageIndex || 0,\n-        images: [] // Initialize empty, will be updated after upload\n-      })) || [],\n-      profile: null // Initialize as null, will be updated after upload\n-    };\n+    const hasShop = await checkExistingShop(userId);\n+    if (hasShop) {\n+      throw new Error('User already has a shop');\n+    }  \n+    try {\n+      console.log('Starting shop data save:', { userId, data });\n \n-    // Save initial clean data\n-    const shopRef = doc(db, 'shops', userId);\n-    await setDoc(shopRef, shopData);\n-\n-    // Now try image uploads with new CORS configuration\n-    if (data.profile?.file) {\n-      try {\n-        const profileUrl = await uploadImageWithCORS(\n-          data.profile.file,\n-          `shops/${userId}/profile/profile-${Date.now()}`\n-        );\n-        \n-        if (profileUrl) {\n-          shopData.profile = profileUrl;\n-          await updateDoc(shopRef, {\n-            profile: profileUrl,\n-            updatedAt: new Date().toISOString()\n-          });\n-        }\n-      } catch (profileError) {\n-        console.error('Profile upload failed:', profileError);\n-      }\n-    }\n-\n-    // Try uploading item images\n-    if (Array.isArray(data.items)) {\n-      const processedItems = await Promise.all(data.items.map(async (item) => {\n-        const processedItem = {\n+      // Clean data before saving to Firestore\n+      let shopData = {\n+        name: data.name || '',\n+        description: data.description || '',\n+        theme: cleanDataForFirestore(data.theme) || {},\n+        layout: cleanDataForFirestore(data.layout) || {},\n+        createdAt: new Date().toISOString(),\n+        updatedAt: new Date().toISOString(),\n+        userId: userId,\n+        items: data.items?.map(item => ({\n           id: item.id || Date.now().toString(),\n           name: item.name || '',\n           price: item.price || '',\n           description: item.description || '',\n           currentImageIndex: item.currentImageIndex || 0,\n-          images: []\n-        };\n-    \n-        if (Array.isArray(item.images)) {\n-          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n-            if (!image?.file) return null;\n-            \n-            return await uploadImageWithCORS(\n-              image.file,\n-              `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n-            );\n-          }));\n-          \n-          processedItem.images = imageUrls.filter(Boolean);\n+          images: [] // Initialize empty, will be updated after upload\n+        })) || [],\n+        profile: null // Initialize as null, will be updated after upload\n+      };\n+\n+      // Save initial clean data\n+      const shopRef = doc(db, 'shops', userId);\n+      await setDoc(shopRef, shopData);\n+\n+      // Now try image uploads with new CORS configuration\n+      if (data.profile?.file) {\n+        try {\n+          const profileUrl = await uploadImageWithCORS(\n+            data.profile.file,\n+            `shops/${userId}/profile/profile-${Date.now()}`\n+          );\n+\n+          if (profileUrl) {\n+            shopData.profile = profileUrl;\n+            await updateDoc(shopRef, {\n+              profile: profileUrl,\n+              updatedAt: new Date().toISOString()\n+            });\n+          }\n+        } catch (profileError) {\n+          console.error('Profile upload failed:', profileError);\n         }\n-    \n-        return processedItem;\n-      }));\n-    \n-      shopData.items = processedItems;\n-    \n-      // Update items in Firestore\n-      await updateDoc(shopRef, {\n-        items: processedItems,\n-        updatedAt: new Date().toISOString()\n-      });\n-    }\n+      }\n \n-    console.log('Shop data saved successfully:', shopData);\n-    return shopData;\n+      // Try uploading item images\n+      if (Array.isArray(data.items)) {\n+        const processedItems = await Promise.all(data.items.map(async (item) => {\n+          const processedItem = {\n+            id: item.id || Date.now().toString(),\n+            name: item.name || '',\n+            price: item.price || '',\n+            description: item.description || '',\n+            currentImageIndex: item.currentImageIndex || 0,\n+            images: []\n+          };\n+        \n+          if (Array.isArray(item.images)) {\n+            const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n+              if (!image?.file) return null;\n \n-  } catch (err) {\n-    console.error('Error in saveShopData:', err);\n-    throw err;\n+              return await uploadImageWithCORS(\n+                image.file,\n+                `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n+              );\n+            }));\n+\n+            processedItem.images = imageUrls.filter(Boolean);\n+          }\n+        \n+          return processedItem;\n+        }));\n+      \n+        shopData.items = processedItems;\n+      \n+        // Update items in Firestore\n+        await updateDoc(shopRef, {\n+          items: processedItems,\n+          updatedAt: new Date().toISOString()\n+        });\n+      }\n+\n+      console.log('Shop data saved successfully:', shopData);\n+      return shopData;\n+\n+    } catch (err) {\n+      console.error('Error in saveShopData:', err);\n+      throw err;\n+    }\n+  } catch (error) {\n+    console.error('Error in saveShopData:', error);\n+    throw error;\n   }\n };\n \n // Add new function for image uploads\n"
                }
            ],
            "date": 1738038751717,
            "name": "Commit-0",
            "content": "// src/firebase/firebaseService.js\n\nimport { \n  doc, \n  setDoc, \n  getDoc, \n  updateDoc,\n  collection,\n  query,\n  where,\n  getDocs\n} from 'firebase/firestore';\nimport { \n  ref, \n  uploadBytes, \n  getDownloadURL \n} from 'firebase/storage';\nimport { db, storage } from './config';\n\n// Shop Operations\n// Also update the saveShopData function to log the structured data\n// Update the saveShopData function in firebaseService.js\n\n// Update the saveShopData function in firebaseService.js\n// src/firebase/firebaseService.js\n\n// In firebaseService.js\n\nexport const getFeaturedItems = async (limit = 6) => {\n  try {\n    // Get all shop documents\n    const shopsRef = collection(db, 'shops');\n    const shopsSnapshot = await getDocs(shopsRef);\n    \n    // Collect all items from all shops\n    let allItems = [];\n    shopsSnapshot.forEach(doc => {\n      const shop = doc.data();\n      const shopId = doc.id;\n      \n      // Only add items that have images and required fields\n      const validItems = (shop.items || []).filter(item => \n        item.name && \n        item.price && \n        item.images && \n        item.images.length > 0\n      ).map(item => ({\n        ...item,\n        shopId,\n        shopName: shop.name,\n        shopTheme: shop.theme\n      }));\n      \n      allItems = [...allItems, ...validItems];\n    });\n    \n    // Sort by newest first (assuming items have a timestamp)\n    allItems.sort((a, b) => b.createdAt - a.createdAt);\n    \n    // Return limited number of items\n    return allItems.slice(0, limit);\n  } catch (error) {\n    console.error('Error fetching featured items:', error);\n    return [];\n  }\n};\n\n// Add this utility function to clean data before saving to Firestore\nconst cleanDataForFirestore = (data) => {\n  if (!data) return data;\n  \n  if (Array.isArray(data)) {\n    return data.map(item => cleanDataForFirestore(item));\n  }\n  \n  if (typeof data === 'object' && !(data instanceof Date)) {\n    const cleanedData = {};\n    for (const [key, value] of Object.entries(data)) {\n      // Skip file objects and null/undefined values\n      if (value instanceof File || value === null || value === undefined) {\n        continue;\n      }\n      cleanedData[key] = cleanDataForFirestore(value);\n    }\n    return cleanedData;\n  }\n  \n  return data;\n};\n\n// Add this helper function at the top\nconst uploadImageWithCORS = async (file, path) => {\n  if (!file) return null;\n  \n  const metadata = {\n    contentType: file.type || 'image/jpeg',\n    cacheControl: 'public,max-age=3600',\n    customMetadata: {\n      'Access-Control-Allow-Origin': '*'\n    }\n  };\n\n  try {\n    // Create a blob with CORS headers\n    const blob = new Blob([file], { type: file.type });\n    const imageRef = ref(storage, path);\n    const snapshot = await uploadBytes(imageRef, blob, metadata);\n    return await getDownloadURL(snapshot.ref);\n  } catch (error) {\n    console.error('Error uploading image:', error);\n    return null;\n  }\n};\n\nexport const saveShopData = async (userId, data) => {\n  try {\n    console.log('Starting shop data save:', { userId, data });\n    \n    // Clean data before saving to Firestore\n    let shopData = {\n      name: data.name || '',\n      description: data.description || '',\n      theme: cleanDataForFirestore(data.theme) || {},\n      layout: cleanDataForFirestore(data.layout) || {},\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      userId: userId,\n      items: data.items?.map(item => ({\n        id: item.id || Date.now().toString(),\n        name: item.name || '',\n        price: item.price || '',\n        description: item.description || '',\n        currentImageIndex: item.currentImageIndex || 0,\n        images: [] // Initialize empty, will be updated after upload\n      })) || [],\n      profile: null // Initialize as null, will be updated after upload\n    };\n\n    // Save initial clean data\n    const shopRef = doc(db, 'shops', userId);\n    await setDoc(shopRef, shopData);\n\n    // Now try image uploads with new CORS configuration\n    if (data.profile?.file) {\n      try {\n        const profileUrl = await uploadImageWithCORS(\n          data.profile.file,\n          `shops/${userId}/profile/profile-${Date.now()}`\n        );\n        \n        if (profileUrl) {\n          shopData.profile = profileUrl;\n          await updateDoc(shopRef, {\n            profile: profileUrl,\n            updatedAt: new Date().toISOString()\n          });\n        }\n      } catch (profileError) {\n        console.error('Profile upload failed:', profileError);\n      }\n    }\n\n    // Try uploading item images\n    if (Array.isArray(data.items)) {\n      const processedItems = await Promise.all(data.items.map(async (item) => {\n        const processedItem = {\n          id: item.id || Date.now().toString(),\n          name: item.name || '',\n          price: item.price || '',\n          description: item.description || '',\n          currentImageIndex: item.currentImageIndex || 0,\n          images: []\n        };\n    \n        if (Array.isArray(item.images)) {\n          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n            if (!image?.file) return null;\n            \n            return await uploadImageWithCORS(\n              image.file,\n              `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n            );\n          }));\n          \n          processedItem.images = imageUrls.filter(Boolean);\n        }\n    \n        return processedItem;\n      }));\n    \n      shopData.items = processedItems;\n    \n      // Update items in Firestore\n      await updateDoc(shopRef, {\n        items: processedItems,\n        updatedAt: new Date().toISOString()\n      });\n    }\n\n    console.log('Shop data saved successfully:', shopData);\n    return shopData;\n\n  } catch (err) {\n    console.error('Error in saveShopData:', err);\n    throw err;\n  }\n};\n\n// Add new function for image uploads\nexport const uploadShopImages = async (userId, data) => {\n  try {\n    const shopRef = doc(db, 'shops', userId);\n    let updates = {};\n\n    // Handle profile image\n    if (data.profile?.file instanceof File) {\n      try {\n        const metadata = {\n          contentType: data.profile.type || 'image/jpeg'\n        };\n        const profileRef = ref(storage, `shops/${userId}/profile/profile-${Date.now()}`);\n        const profileSnapshot = await uploadBytes(profileRef, data.profile.file, metadata);\n        updates.profile = await getDownloadURL(profileSnapshot.ref);\n      } catch (error) {\n        console.error('Profile upload failed:', error);\n      }\n    }\n\n    // Handle item images\n    if (Array.isArray(data.items)) {\n      updates.items = await Promise.all(data.items.map(async (item) => {\n        const processedItem = {\n          id: item.id,\n          name: item.name || '',\n          price: item.price || '',\n          description: item.description || '',\n          currentImageIndex: item.currentImageIndex || 0,\n          images: []\n        };\n\n        if (Array.isArray(item.images)) {\n          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n            if (!(image?.file instanceof File)) return null;\n            \n            try {\n              const metadata = {\n                contentType: image.type || 'image/jpeg'\n              };\n              const imageRef = ref(storage, `shops/${userId}/items/${item.id}/image-${index}-${Date.now()}`);\n              const snapshot = await uploadBytes(imageRef, image.file, metadata);\n              return await getDownloadURL(snapshot.ref);\n            } catch (error) {\n              console.error(`Failed to upload image ${index}:`, error);\n              return null;\n            }\n          }));\n          \n          processedItem.images = imageUrls.filter(Boolean);\n        }\n\n        return processedItem;\n      }));\n    }\n\n    // Clean updates before saving to Firestore\n    const cleanUpdates = cleanDataForFirestore({\n      ...updates,\n      updatedAt: new Date().toISOString()\n    });\n\n    // Update Firestore with clean data\n    if (Object.keys(cleanUpdates).length > 0) {\n      await updateDoc(shopRef, cleanUpdates);\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error uploading images:', error);\n    throw error;\n  }\n};\n\nexport const getShopData = async (userId) => {\n  try {\n    const shopRef = doc(db, 'shops', userId);\n    const shopSnap = await getDoc(shopRef);\n    \n    if (shopSnap.exists()) {\n      return shopSnap.data();\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Error getting shop data:', error);\n    throw error;\n  }\n};\n\nexport const updateShopData = async (userId, updateData) => {\n  try {\n    const shopRef = doc(db, 'shops', userId);\n    \n    // Handle any new image uploads\n    let updates = { ...updateData };\n    \n    if (updateData.profile?.file) {\n      const profileRef = ref(storage, `shops/${userId}/profile`);\n      await uploadBytes(profileRef, updateData.profile.file);\n      updates.profileImage = await getDownloadURL(profileRef);\n    }\n\n    if (updateData.items) {\n      updates.items = await Promise.all(updateData.items.map(async (item, index) => {\n        const processedItem = { ...item };\n        if (item.images) {\n          const processedImages = await Promise.all(item.images.map(async (image, imgIndex) => {\n            if (image?.file) {\n              const imageRef = ref(storage, `shops/${userId}/items/${index}/${imgIndex}`);\n              await uploadBytes(imageRef, image.file);\n              return await getDownloadURL(imageRef);\n            }\n            return image; // Keep existing image URL if no new file\n          }));\n          processedItem.images = processedImages;\n        }\n        return processedItem;\n      }));\n    }\n\n    await updateDoc(shopRef, {\n      ...updates,\n      updatedAt: new Date().toISOString()\n    });\n\n    return true;\n  } catch (error) {\n    console.error('Error updating shop data:', error);\n    throw error;\n  }\n};\n\n// Search Operations\nexport const searchShops = async (searchTerm) => {\n  try {\n    const shopsRef = collection(db, 'shops');\n    const q = query(\n      shopsRef,\n      where('status', '==', 'active'),\n      where('searchTerms', 'array-contains', searchTerm.toLowerCase())\n    );\n    \n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error searching shops:', error);\n    throw error;\n  }\n};\n\n// Helper function to create search terms for better search functionality\nexport const generateSearchTerms = (shopData) => {\n  const terms = new Set();\n  \n  // Add shop name terms\n  if (shopData.shopName) {\n    const words = shopData.shopName.toLowerCase().split(' ');\n    words.forEach(word => terms.add(word));\n  }\n\n  // Add item names and tags\n  if (shopData.items) {\n    shopData.items.forEach(item => {\n      if (item.name) {\n        const words = item.name.toLowerCase().split(' ');\n        words.forEach(word => terms.add(word));\n      }\n      if (item.tags) {\n        item.tags.forEach(tag => terms.add(tag.toLowerCase()));\n      }\n    });\n  }\n\n  return Array.from(terms);\n};\n"
        }
    ]
}