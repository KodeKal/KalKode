{
    "sourceFile": "src/firebase/firebaseService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1738038751717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1738039103268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,8 +64,33 @@\n     return [];\n   }\n };\n \n+export const checkExistingShop = async (userId) => {\n+  try {\n+    const shopRef = doc(db, 'shops', userId);\n+    const shopDoc = await getDoc(shopRef);\n+    return shopDoc.exists();\n+  } catch (error) {\n+    console.error('Error checking existing shop:', error);\n+    throw error;\n+  }\n+};\n+\n+// Update saveShopData to check first\n+export const saveShopData = async (userId, data) => {\n+  try {\n+    const hasShop = await checkExistingShop(userId);\n+    if (hasShop) {\n+      throw new Error('User already has a shop');\n+    }\n+    // ... rest of the existing saveShopData code\n+  } catch (error) {\n+    console.error('Error in saveShopData:', error);\n+    throw error;\n+  }\n+};\n+\n // Add this utility function to clean data before saving to Firestore\n const cleanDataForFirestore = (data) => {\n   if (!data) return data;\n   \n"
                },
                {
                    "date": 1738039688171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,22 +75,8 @@\n     throw error;\n   }\n };\n \n-// Update saveShopData to check first\n-export const saveShopData = async (userId, data) => {\n-  try {\n-    const hasShop = await checkExistingShop(userId);\n-    if (hasShop) {\n-      throw new Error('User already has a shop');\n-    }\n-    // ... rest of the existing saveShopData code\n-  } catch (error) {\n-    console.error('Error in saveShopData:', error);\n-    throw error;\n-  }\n-};\n-\n // Add this utility function to clean data before saving to Firestore\n const cleanDataForFirestore = (data) => {\n   if (!data) return data;\n   \n@@ -138,97 +124,106 @@\n };\n \n export const saveShopData = async (userId, data) => {\n   try {\n-    console.log('Starting shop data save:', { userId, data });\n-    \n-    // Clean data before saving to Firestore\n-    let shopData = {\n-      name: data.name || '',\n-      description: data.description || '',\n-      theme: cleanDataForFirestore(data.theme) || {},\n-      layout: cleanDataForFirestore(data.layout) || {},\n-      createdAt: new Date().toISOString(),\n-      updatedAt: new Date().toISOString(),\n-      userId: userId,\n-      items: data.items?.map(item => ({\n-        id: item.id || Date.now().toString(),\n-        name: item.name || '',\n-        price: item.price || '',\n-        description: item.description || '',\n-        currentImageIndex: item.currentImageIndex || 0,\n-        images: [] // Initialize empty, will be updated after upload\n-      })) || [],\n-      profile: null // Initialize as null, will be updated after upload\n-    };\n+    const hasShop = await checkExistingShop(userId);\n+    if (hasShop) {\n+      throw new Error('User already has a shop');\n+    }  \n+    try {\n+      console.log('Starting shop data save:', { userId, data });\n \n-    // Save initial clean data\n-    const shopRef = doc(db, 'shops', userId);\n-    await setDoc(shopRef, shopData);\n-\n-    // Now try image uploads with new CORS configuration\n-    if (data.profile?.file) {\n-      try {\n-        const profileUrl = await uploadImageWithCORS(\n-          data.profile.file,\n-          `shops/${userId}/profile/profile-${Date.now()}`\n-        );\n-        \n-        if (profileUrl) {\n-          shopData.profile = profileUrl;\n-          await updateDoc(shopRef, {\n-            profile: profileUrl,\n-            updatedAt: new Date().toISOString()\n-          });\n-        }\n-      } catch (profileError) {\n-        console.error('Profile upload failed:', profileError);\n-      }\n-    }\n-\n-    // Try uploading item images\n-    if (Array.isArray(data.items)) {\n-      const processedItems = await Promise.all(data.items.map(async (item) => {\n-        const processedItem = {\n+      // Clean data before saving to Firestore\n+      let shopData = {\n+        name: data.name || '',\n+        description: data.description || '',\n+        theme: cleanDataForFirestore(data.theme) || {},\n+        layout: cleanDataForFirestore(data.layout) || {},\n+        createdAt: new Date().toISOString(),\n+        updatedAt: new Date().toISOString(),\n+        userId: userId,\n+        items: data.items?.map(item => ({\n           id: item.id || Date.now().toString(),\n           name: item.name || '',\n           price: item.price || '',\n           description: item.description || '',\n           currentImageIndex: item.currentImageIndex || 0,\n-          images: []\n-        };\n-    \n-        if (Array.isArray(item.images)) {\n-          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n-            if (!image?.file) return null;\n-            \n-            return await uploadImageWithCORS(\n-              image.file,\n-              `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n-            );\n-          }));\n-          \n-          processedItem.images = imageUrls.filter(Boolean);\n+          images: [] // Initialize empty, will be updated after upload\n+        })) || [],\n+        profile: null // Initialize as null, will be updated after upload\n+      };\n+\n+      // Save initial clean data\n+      const shopRef = doc(db, 'shops', userId);\n+      await setDoc(shopRef, shopData);\n+\n+      // Now try image uploads with new CORS configuration\n+      if (data.profile?.file) {\n+        try {\n+          const profileUrl = await uploadImageWithCORS(\n+            data.profile.file,\n+            `shops/${userId}/profile/profile-${Date.now()}`\n+          );\n+\n+          if (profileUrl) {\n+            shopData.profile = profileUrl;\n+            await updateDoc(shopRef, {\n+              profile: profileUrl,\n+              updatedAt: new Date().toISOString()\n+            });\n+          }\n+        } catch (profileError) {\n+          console.error('Profile upload failed:', profileError);\n         }\n-    \n-        return processedItem;\n-      }));\n-    \n-      shopData.items = processedItems;\n-    \n-      // Update items in Firestore\n-      await updateDoc(shopRef, {\n-        items: processedItems,\n-        updatedAt: new Date().toISOString()\n-      });\n-    }\n+      }\n \n-    console.log('Shop data saved successfully:', shopData);\n-    return shopData;\n+      // Try uploading item images\n+      if (Array.isArray(data.items)) {\n+        const processedItems = await Promise.all(data.items.map(async (item) => {\n+          const processedItem = {\n+            id: item.id || Date.now().toString(),\n+            name: item.name || '',\n+            price: item.price || '',\n+            description: item.description || '',\n+            currentImageIndex: item.currentImageIndex || 0,\n+            images: []\n+          };\n+        \n+          if (Array.isArray(item.images)) {\n+            const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n+              if (!image?.file) return null;\n \n-  } catch (err) {\n-    console.error('Error in saveShopData:', err);\n-    throw err;\n+              return await uploadImageWithCORS(\n+                image.file,\n+                `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n+              );\n+            }));\n+\n+            processedItem.images = imageUrls.filter(Boolean);\n+          }\n+        \n+          return processedItem;\n+        }));\n+      \n+        shopData.items = processedItems;\n+      \n+        // Update items in Firestore\n+        await updateDoc(shopRef, {\n+          items: processedItems,\n+          updatedAt: new Date().toISOString()\n+        });\n+      }\n+\n+      console.log('Shop data saved successfully:', shopData);\n+      return shopData;\n+\n+    } catch (err) {\n+      console.error('Error in saveShopData:', err);\n+      throw err;\n+    }\n+  } catch (error) {\n+    console.error('Error in saveShopData:', error);\n+    throw error;\n   }\n };\n \n // Add new function for image uploads\n"
                },
                {
                    "date": 1759189965909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,407 +1,637 @@\n-// src/firebase/firebaseService.js\n-\n-import { \n-  doc, \n-  setDoc, \n-  getDoc, \n-  updateDoc,\n-  collection,\n-  query,\n-  where,\n-  getDocs\n-} from 'firebase/firestore';\n-import { \n-  ref, \n-  uploadBytes, \n-  getDownloadURL \n-} from 'firebase/storage';\n-import { db, storage } from './config';\n-\n-// Shop Operations\n-// Also update the saveShopData function to log the structured data\n-// Update the saveShopData function in firebaseService.js\n-\n-// Update the saveShopData function in firebaseService.js\n-// src/firebase/firebaseService.js\n-\n-// In firebaseService.js\n-\n-export const getFeaturedItems = async (limit = 6) => {\n-  try {\n-    // Get all shop documents\n-    const shopsRef = collection(db, 'shops');\n-    const shopsSnapshot = await getDocs(shopsRef);\n-    \n-    // Collect all items from all shops\n-    let allItems = [];\n-    shopsSnapshot.forEach(doc => {\n-      const shop = doc.data();\n-      const shopId = doc.id;\n-      \n-      // Only add items that have images and required fields\n-      const validItems = (shop.items || []).filter(item => \n-        item.name && \n-        item.price && \n-        item.images && \n-        item.images.length > 0\n-      ).map(item => ({\n-        ...item,\n-        shopId,\n-        shopName: shop.name,\n-        shopTheme: shop.theme\n-      }));\n-      \n-      allItems = [...allItems, ...validItems];\n-    });\n-    \n-    // Sort by newest first (assuming items have a timestamp)\n-    allItems.sort((a, b) => b.createdAt - a.createdAt);\n-    \n-    // Return limited number of items\n-    return allItems.slice(0, limit);\n-  } catch (error) {\n-    console.error('Error fetching featured items:', error);\n-    return [];\n-  }\n-};\n-\n-export const checkExistingShop = async (userId) => {\n-  try {\n-    const shopRef = doc(db, 'shops', userId);\n-    const shopDoc = await getDoc(shopRef);\n-    return shopDoc.exists();\n-  } catch (error) {\n-    console.error('Error checking existing shop:', error);\n-    throw error;\n-  }\n-};\n-\n-// Add this utility function to clean data before saving to Firestore\n-const cleanDataForFirestore = (data) => {\n-  if (!data) return data;\n-  \n-  if (Array.isArray(data)) {\n-    return data.map(item => cleanDataForFirestore(item));\n-  }\n-  \n-  if (typeof data === 'object' && !(data instanceof Date)) {\n-    const cleanedData = {};\n-    for (const [key, value] of Object.entries(data)) {\n-      // Skip file objects and null/undefined values\n-      if (value instanceof File || value === null || value === undefined) {\n-        continue;\n-      }\n-      cleanedData[key] = cleanDataForFirestore(value);\n-    }\n-    return cleanedData;\n-  }\n-  \n-  return data;\n-};\n-\n-// Add this helper function at the top\n-const uploadImageWithCORS = async (file, path) => {\n-  if (!file) return null;\n-  \n-  const metadata = {\n-    contentType: file.type || 'image/jpeg',\n-    cacheControl: 'public,max-age=3600',\n-    customMetadata: {\n-      'Access-Control-Allow-Origin': '*'\n-    }\n-  };\n-\n-  try {\n-    // Create a blob with CORS headers\n-    const blob = new Blob([file], { type: file.type });\n-    const imageRef = ref(storage, path);\n-    const snapshot = await uploadBytes(imageRef, blob, metadata);\n-    return await getDownloadURL(snapshot.ref);\n-  } catch (error) {\n-    console.error('Error uploading image:', error);\n-    return null;\n-  }\n-};\n-\n-export const saveShopData = async (userId, data) => {\n-  try {\n-    const hasShop = await checkExistingShop(userId);\n-    if (hasShop) {\n-      throw new Error('User already has a shop');\n-    }  \n-    try {\n-      console.log('Starting shop data save:', { userId, data });\n-\n-      // Clean data before saving to Firestore\n-      let shopData = {\n-        name: data.name || '',\n-        description: data.description || '',\n-        theme: cleanDataForFirestore(data.theme) || {},\n-        layout: cleanDataForFirestore(data.layout) || {},\n-        createdAt: new Date().toISOString(),\n-        updatedAt: new Date().toISOString(),\n-        userId: userId,\n-        items: data.items?.map(item => ({\n-          id: item.id || Date.now().toString(),\n-          name: item.name || '',\n-          price: item.price || '',\n-          description: item.description || '',\n-          currentImageIndex: item.currentImageIndex || 0,\n-          images: [] // Initialize empty, will be updated after upload\n-        })) || [],\n-        profile: null // Initialize as null, will be updated after upload\n-      };\n-\n-      // Save initial clean data\n-      const shopRef = doc(db, 'shops', userId);\n-      await setDoc(shopRef, shopData);\n-\n-      // Now try image uploads with new CORS configuration\n-      if (data.profile?.file) {\n-        try {\n-          const profileUrl = await uploadImageWithCORS(\n-            data.profile.file,\n-            `shops/${userId}/profile/profile-${Date.now()}`\n-          );\n-\n-          if (profileUrl) {\n-            shopData.profile = profileUrl;\n-            await updateDoc(shopRef, {\n-              profile: profileUrl,\n-              updatedAt: new Date().toISOString()\n-            });\n-          }\n-        } catch (profileError) {\n-          console.error('Profile upload failed:', profileError);\n-        }\n-      }\n-\n-      // Try uploading item images\n-      if (Array.isArray(data.items)) {\n-        const processedItems = await Promise.all(data.items.map(async (item) => {\n-          const processedItem = {\n-            id: item.id || Date.now().toString(),\n-            name: item.name || '',\n-            price: item.price || '',\n-            description: item.description || '',\n-            currentImageIndex: item.currentImageIndex || 0,\n-            images: []\n-          };\n-        \n-          if (Array.isArray(item.images)) {\n-            const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n-              if (!image?.file) return null;\n-\n-              return await uploadImageWithCORS(\n-                image.file,\n-                `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n-              );\n-            }));\n-\n-            processedItem.images = imageUrls.filter(Boolean);\n-          }\n-        \n-          return processedItem;\n-        }));\n-      \n-        shopData.items = processedItems;\n-      \n-        // Update items in Firestore\n-        await updateDoc(shopRef, {\n-          items: processedItems,\n-          updatedAt: new Date().toISOString()\n-        });\n-      }\n-\n-      console.log('Shop data saved successfully:', shopData);\n-      return shopData;\n-\n-    } catch (err) {\n-      console.error('Error in saveShopData:', err);\n-      throw err;\n-    }\n-  } catch (error) {\n-    console.error('Error in saveShopData:', error);\n-    throw error;\n-  }\n-};\n-\n-// Add new function for image uploads\n-export const uploadShopImages = async (userId, data) => {\n-  try {\n-    const shopRef = doc(db, 'shops', userId);\n-    let updates = {};\n-\n-    // Handle profile image\n-    if (data.profile?.file instanceof File) {\n-      try {\n-        const metadata = {\n-          contentType: data.profile.type || 'image/jpeg'\n-        };\n-        const profileRef = ref(storage, `shops/${userId}/profile/profile-${Date.now()}`);\n-        const profileSnapshot = await uploadBytes(profileRef, data.profile.file, metadata);\n-        updates.profile = await getDownloadURL(profileSnapshot.ref);\n-      } catch (error) {\n-        console.error('Profile upload failed:', error);\n-      }\n-    }\n-\n-    // Handle item images\n-    if (Array.isArray(data.items)) {\n-      updates.items = await Promise.all(data.items.map(async (item) => {\n-        const processedItem = {\n-          id: item.id,\n-          name: item.name || '',\n-          price: item.price || '',\n-          description: item.description || '',\n-          currentImageIndex: item.currentImageIndex || 0,\n-          images: []\n-        };\n-\n-        if (Array.isArray(item.images)) {\n-          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n-            if (!(image?.file instanceof File)) return null;\n-            \n-            try {\n-              const metadata = {\n-                contentType: image.type || 'image/jpeg'\n-              };\n-              const imageRef = ref(storage, `shops/${userId}/items/${item.id}/image-${index}-${Date.now()}`);\n-              const snapshot = await uploadBytes(imageRef, image.file, metadata);\n-              return await getDownloadURL(snapshot.ref);\n-            } catch (error) {\n-              console.error(`Failed to upload image ${index}:`, error);\n-              return null;\n-            }\n-          }));\n-          \n-          processedItem.images = imageUrls.filter(Boolean);\n-        }\n-\n-        return processedItem;\n-      }));\n-    }\n-\n-    // Clean updates before saving to Firestore\n-    const cleanUpdates = cleanDataForFirestore({\n-      ...updates,\n-      updatedAt: new Date().toISOString()\n-    });\n-\n-    // Update Firestore with clean data\n-    if (Object.keys(cleanUpdates).length > 0) {\n-      await updateDoc(shopRef, cleanUpdates);\n-    }\n-\n-    return true;\n-  } catch (error) {\n-    console.error('Error uploading images:', error);\n-    throw error;\n-  }\n-};\n-\n-export const getShopData = async (userId) => {\n-  try {\n-    const shopRef = doc(db, 'shops', userId);\n-    const shopSnap = await getDoc(shopRef);\n-    \n-    if (shopSnap.exists()) {\n-      return shopSnap.data();\n-    }\n-    \n-    return null;\n-  } catch (error) {\n-    console.error('Error getting shop data:', error);\n-    throw error;\n-  }\n-};\n-\n-export const updateShopData = async (userId, updateData) => {\n-  try {\n-    const shopRef = doc(db, 'shops', userId);\n-    \n-    // Handle any new image uploads\n-    let updates = { ...updateData };\n-    \n-    if (updateData.profile?.file) {\n-      const profileRef = ref(storage, `shops/${userId}/profile`);\n-      await uploadBytes(profileRef, updateData.profile.file);\n-      updates.profileImage = await getDownloadURL(profileRef);\n-    }\n-\n-    if (updateData.items) {\n-      updates.items = await Promise.all(updateData.items.map(async (item, index) => {\n-        const processedItem = { ...item };\n-        if (item.images) {\n-          const processedImages = await Promise.all(item.images.map(async (image, imgIndex) => {\n-            if (image?.file) {\n-              const imageRef = ref(storage, `shops/${userId}/items/${index}/${imgIndex}`);\n-              await uploadBytes(imageRef, image.file);\n-              return await getDownloadURL(imageRef);\n-            }\n-            return image; // Keep existing image URL if no new file\n-          }));\n-          processedItem.images = processedImages;\n-        }\n-        return processedItem;\n-      }));\n-    }\n-\n-    await updateDoc(shopRef, {\n-      ...updates,\n-      updatedAt: new Date().toISOString()\n-    });\n-\n-    return true;\n-  } catch (error) {\n-    console.error('Error updating shop data:', error);\n-    throw error;\n-  }\n-};\n-\n-// Search Operations\n-export const searchShops = async (searchTerm) => {\n-  try {\n-    const shopsRef = collection(db, 'shops');\n-    const q = query(\n-      shopsRef,\n-      where('status', '==', 'active'),\n-      where('searchTerms', 'array-contains', searchTerm.toLowerCase())\n-    );\n-    \n-    const querySnapshot = await getDocs(q);\n-    return querySnapshot.docs.map(doc => ({\n-      id: doc.id,\n-      ...doc.data()\n-    }));\n-  } catch (error) {\n-    console.error('Error searching shops:', error);\n-    throw error;\n-  }\n-};\n-\n-// Helper function to create search terms for better search functionality\n-export const generateSearchTerms = (shopData) => {\n-  const terms = new Set();\n-  \n-  // Add shop name terms\n-  if (shopData.shopName) {\n-    const words = shopData.shopName.toLowerCase().split(' ');\n-    words.forEach(word => terms.add(word));\n-  }\n-\n-  // Add item names and tags\n-  if (shopData.items) {\n-    shopData.items.forEach(item => {\n-      if (item.name) {\n-        const words = item.name.toLowerCase().split(' ');\n-        words.forEach(word => terms.add(word));\n-      }\n-      if (item.tags) {\n-        item.tags.forEach(tag => terms.add(tag.toLowerCase()));\n-      }\n-    });\n-  }\n-\n-  return Array.from(terms);\n-};\n+// src/firebase/firebaseService.js - Updated with Batch Operations\r\n+\r\n+import { \r\n+  doc, \r\n+  setDoc, \r\n+  getDoc, \r\n+  updateDoc,\r\n+  collection,\r\n+  query,\r\n+  where,\r\n+  getDocs,\r\n+  limit,\r\n+  writeBatch // Add batch import\r\n+} from 'firebase/firestore';\r\n+import { \r\n+  ref, \r\n+  uploadBytes, \r\n+  getDownloadURL \r\n+} from 'firebase/storage';\r\n+import { db, storage } from './config';\r\n+\r\n+// Shop Operations\r\n+export const getFeaturedItems = async (limitCount = 6) => {\r\n+  try {\r\n+    const shopsRef = collection(db, 'shops');\r\n+    const querySnapshot = await getDocs(shopsRef);\r\n+    \r\n+    let allItems = [];\r\n+    querySnapshot.docs.forEach(doc => {\r\n+      const shopData = doc.data();\r\n+      if (shopData?.items && Array.isArray(shopData.items)) {\r\n+        const shopItems = shopData.items\r\n+          .filter(item => !item.deleted)\r\n+          .map(item => ({\r\n+            ...item,\r\n+            shopId: doc.id,\r\n+            shopName: shopData.name || 'Unknown Shop',\r\n+            shopTheme: shopData.theme || {},\r\n+            quantity: item.quantity || 1\r\n+          }));\r\n+        allItems = [...allItems, ...shopItems];\r\n+      }\r\n+    });\r\n+\r\n+    // Sort by most recent first\r\n+    allItems.sort((a, b) => {\r\n+      const dateA = a.createdAt ? new Date(a.createdAt) : new Date(0);\r\n+      const dateB = b.createdAt ? new Date(b.createdAt) : new Date(0);\r\n+      return dateB - dateA;\r\n+    });\r\n+\r\n+    // Return only the requested number of items\r\n+    return allItems.slice(0, limitCount);\r\n+  } catch (error) {\r\n+    console.error('Error fetching featured items:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+export const checkExistingShop = async (userId) => {\r\n+  try {\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    const shopDoc = await getDoc(shopRef);\r\n+    return shopDoc.exists();\r\n+  } catch (error) {\r\n+    console.error('Error checking existing shop:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Add this utility function to clean data before saving to Firestore\r\n+const cleanDataForFirestore = (data) => {\r\n+  if (!data) return data;\r\n+  \r\n+  if (Array.isArray(data)) {\r\n+    return data.map(item => cleanDataForFirestore(item));\r\n+  }\r\n+  \r\n+  if (typeof data === 'object' && !(data instanceof Date)) {\r\n+    const cleanedData = {};\r\n+    for (const [key, value] of Object.entries(data)) {\r\n+      // Skip file objects and null/undefined values\r\n+      if (value instanceof File || value === null || value === undefined) {\r\n+        continue;\r\n+      }\r\n+      cleanedData[key] = cleanDataForFirestore(value);\r\n+    }\r\n+    return cleanedData;\r\n+  }\r\n+  \r\n+  return data;\r\n+};\r\n+\r\n+// Add to firebaseService.js\r\n+export const saveInitialShop = async (userId, data) => {\r\n+  try {\r\n+    const batch = writeBatch(db);\r\n+    \r\n+    // 1. Create main shop document\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    const shopDoc = {\r\n+      ownerId: userId,\r\n+      name: data.name || '',\r\n+      description: data.description || '',\r\n+      mission: data.mission || '',\r\n+      theme: cleanDataForFirestore(data.theme) || {},\r\n+      layout: cleanDataForFirestore(data.layout) || {},\r\n+      status: 'active',\r\n+      profile: null, // Will update after upload\r\n+      searchTerms: generateSearchTerms({ shopName: data.name }),\r\n+      createdAt: new Date().toISOString(),\r\n+      updatedAt: new Date().toISOString(),\r\n+      stats: {\r\n+        items: 0,\r\n+        views: 0,\r\n+        likes: 0\r\n+      }\r\n+    };\r\n+\r\n+    batch.set(shopRef, shopDoc);\r\n+\r\n+    // 2. Process items\r\n+    const items = [];\r\n+    const locations = [];\r\n+\r\n+    if (Array.isArray(data.items)) {\r\n+      for (const item of data.items) {\r\n+        const itemId = `${userId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n+        const itemRef = doc(db, 'items', itemId);\r\n+\r\n+        // Process images\r\n+        const imageUrls = await Promise.all(item.images.map(async (image, index) => {\r\n+          if (!image?.file) return null;\r\n+          return await uploadImageWithCORS(\r\n+            image.file,\r\n+            `shops/${userId}/items/${itemId}/image-${index}-${Date.now()}`\r\n+          );\r\n+        }));\r\n+\r\n+        const itemDoc = {\r\n+          id: itemId,\r\n+          shopId: userId,\r\n+          name: item.name || '',\r\n+          price: item.price || '',\r\n+          description: item.description || '',\r\n+          images: imageUrls.filter(Boolean),\r\n+          status: 'active',\r\n+          address: item.address || '',\r\n+          coordinates: item.coordinates || null,\r\n+          quantity: item.quantity || 1,\r\n+          views: 0,\r\n+          likes: 0,\r\n+          deleted: false,\r\n+          createdAt: new Date().toISOString(),\r\n+          updatedAt: new Date().toISOString()\r\n+        };\r\n+\r\n+        batch.set(itemRef, itemDoc);\r\n+        items.push(itemDoc);\r\n+\r\n+        // If item has location, create location document\r\n+        if (item.coordinates) {\r\n+          const locationRef = doc(db, 'locations', itemId);\r\n+          const locationDoc = {\r\n+            itemId,\r\n+            shopId: userId,\r\n+            address: item.address,\r\n+            coordinates: item.coordinates,\r\n+            createdAt: new Date().toISOString()\r\n+          };\r\n+          batch.set(locationRef, locationDoc);\r\n+          locations.push(locationDoc);\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    // 3. Upload and set profile image if exists\r\n+    if (data.profile?.file) {\r\n+      const profileUrl = await uploadImageWithCORS(\r\n+        data.profile.file,\r\n+        `shops/${userId}/profile/profile-${Date.now()}`\r\n+      );\r\n+      if (profileUrl) {\r\n+        shopDoc.profile = profileUrl;\r\n+      }\r\n+    }\r\n+\r\n+    // 4. Update stats\r\n+    const statsRef = doc(db, 'stats', userId);\r\n+    batch.set(statsRef, {\r\n+      shopId: userId,\r\n+      views: 0,\r\n+      likes: 0,\r\n+      items: items.length,\r\n+      lastUpdated: new Date().toISOString()\r\n+    });\r\n+\r\n+    // 5. Commit everything\r\n+    await batch.commit();\r\n+\r\n+    return {\r\n+      ...shopDoc,\r\n+      items,\r\n+      locations\r\n+    };\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error saving initial shop:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Add this helper function at the top\r\n+const uploadImageWithCORS = async (file, path) => {\r\n+  if (!file) return null;\r\n+  \r\n+  const metadata = {\r\n+    contentType: file.type || 'image/jpeg',\r\n+    cacheControl: 'public,max-age=3600',\r\n+    customMetadata: {\r\n+      'Access-Control-Allow-Origin': '*'\r\n+    }\r\n+  };\r\n+\r\n+  try {\r\n+    // Create a blob with CORS headers\r\n+    const blob = new Blob([file], { type: file.type });\r\n+    const imageRef = ref(storage, path);\r\n+    const snapshot = await uploadBytes(imageRef, blob, metadata);\r\n+    return await getDownloadURL(snapshot.ref);\r\n+  } catch (error) {\r\n+    console.error('Error uploading image:', error);\r\n+    return null;\r\n+  }\r\n+};\r\n+\r\n+// Updated saveShopData function with coordinates fix\r\n+export const saveShopData = async (userId, data) => {\r\n+  try {\r\n+    const hasShop = await checkExistingShop(userId);\r\n+    if (hasShop) {\r\n+      throw new Error('User already has a shop');\r\n+    }  \r\n+    \r\n+    console.log('Starting shop data save:', { userId, data });\r\n+\r\n+    // Clean data before saving to Firestore\r\n+    let shopData = {\r\n+      name: data.name || '',\r\n+      description: data.description || '',\r\n+      mission: data.mission || '',\r\n+      theme: cleanDataForFirestore(data.theme) || {},\r\n+      layout: cleanDataForFirestore(data.layout) || {},\r\n+      createdAt: new Date().toISOString(),\r\n+      updatedAt: new Date().toISOString(),\r\n+      userId: userId,\r\n+      items: data.items?.map(item => ({\r\n+        id: item.id || Date.now().toString(),\r\n+        name: item.name || '',\r\n+        price: item.price || '',\r\n+        description: item.description || '',\r\n+        category: item.category || 'Other',\r\n+        quantity: item.quantity || 1,\r\n+        currentImageIndex: item.currentImageIndex || 0,\r\n+        address: item.address || '', // FIXED: Added address\r\n+        coordinates: item.coordinates || null, // FIXED: Added coordinates\r\n+        tags: item.tags || [],\r\n+        images: [] // Initialize empty, will be updated after upload\r\n+      })) || [],\r\n+      profile: null // Initialize as null, will be updated after upload\r\n+    };\r\n+\r\n+    console.log('Items with coordinates before save:', \r\n+      shopData.items.filter(i => i.coordinates).map(i => ({\r\n+        id: i.id,\r\n+        name: i.name,\r\n+        address: i.address,\r\n+        coordinates: i.coordinates\r\n+      }))\r\n+    );\r\n+\r\n+    // Save initial clean data\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    await setDoc(shopRef, shopData);\r\n+\r\n+    // Now try image uploads with new CORS configuration\r\n+    if (data.profile?.file) {\r\n+      try {\r\n+        const profileUrl = await uploadImageWithCORS(\r\n+          data.profile.file,\r\n+          `shops/${userId}/profile/profile-${Date.now()}`\r\n+        );\r\n+\r\n+        if (profileUrl) {\r\n+          shopData.profile = profileUrl;\r\n+          await updateDoc(shopRef, {\r\n+            profile: profileUrl,\r\n+            updatedAt: new Date().toISOString()\r\n+          });\r\n+        }\r\n+      } catch (profileError) {\r\n+        console.error('Profile upload failed:', profileError);\r\n+      }\r\n+    }\r\n+\r\n+    // Try uploading item images\r\n+    if (Array.isArray(data.items)) {\r\n+      const processedItems = await Promise.all(data.items.map(async (item) => {\r\n+        const processedItem = {\r\n+          id: item.id || Date.now().toString(),\r\n+          name: item.name || '',\r\n+          price: item.price || '',\r\n+          description: item.description || '',\r\n+          category: item.category || 'Other',\r\n+          currentImageIndex: item.currentImageIndex || 0,\r\n+          quantity: item.quantity || 1,\r\n+          address: item.address || '', // FIXED: Preserve address\r\n+          coordinates: item.coordinates || null, // FIXED: Preserve coordinates\r\n+          tags: item.tags || [],\r\n+          images: []\r\n+        };\r\n+      \r\n+        if (Array.isArray(item.images)) {\r\n+          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\r\n+            if (!image?.file) return null;\r\n+\r\n+            return await uploadImageWithCORS(\r\n+              image.file,\r\n+              `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\r\n+            );\r\n+          }));\r\n+\r\n+          processedItem.images = imageUrls.filter(Boolean);\r\n+        }\r\n+      \r\n+        return processedItem;\r\n+      }));\r\n+      \r\n+      shopData.items = processedItems;\r\n+    \r\n+      console.log('Final items with coordinates:', \r\n+        processedItems.filter(i => i.coordinates).map(i => ({\r\n+          id: i.id,\r\n+          name: i.name,\r\n+          address: i.address,\r\n+          coordinates: i.coordinates\r\n+        }))\r\n+      );\r\n+\r\n+      // Update items in Firestore\r\n+      await updateDoc(shopRef, {\r\n+        items: processedItems,\r\n+        updatedAt: new Date().toISOString()\r\n+      });\r\n+    }\r\n+\r\n+    console.log('Shop data saved successfully with coordinates');\r\n+    return shopData;\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error in saveShopData:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// New batch update function for existing shops\r\n+export const batchUpdateShopData = async (userId, updateData) => {\r\n+  try {\r\n+    console.log('Starting batch update for shop:', userId);\r\n+    \r\n+    const batch = writeBatch(db);\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    \r\n+    // Clean the update data\r\n+    const cleanedData = cleanDataForFirestore({\r\n+      ...updateData,\r\n+      updatedAt: new Date().toISOString()\r\n+    });\r\n+    \r\n+    // Update the main shop document\r\n+    batch.update(shopRef, cleanedData);\r\n+    \r\n+    // If updating items, we might need to update individual item documents\r\n+    // This depends on your data structure - if items are stored as subcollections\r\n+    if (updateData.items && Array.isArray(updateData.items)) {\r\n+      // Update stats\r\n+      const statsRef = doc(db, 'stats', userId);\r\n+      batch.update(statsRef, {\r\n+        items: updateData.items.filter(item => !item.deleted).length,\r\n+        lastUpdated: new Date().toISOString()\r\n+      });\r\n+    }\r\n+    \r\n+    // Commit all updates in a single batch\r\n+    await batch.commit();\r\n+    \r\n+    console.log('Batch update completed successfully');\r\n+    return true;\r\n+    \r\n+  } catch (error) {\r\n+    console.error('Error in batch update:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Add new function for image uploads\r\n+export const uploadShopImages = async (userId, data) => {\r\n+  try {\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    let updates = {};\r\n+\r\n+    // Handle profile image\r\n+    if (data.profile?.file instanceof File) {\r\n+      try {\r\n+        const metadata = {\r\n+          contentType: data.profile.type || 'image/jpeg'\r\n+        };\r\n+        const profileRef = ref(storage, `shops/${userId}/profile/profile-${Date.now()}`);\r\n+        const profileSnapshot = await uploadBytes(profileRef, data.profile.file, metadata);\r\n+        updates.profile = await getDownloadURL(profileSnapshot.ref);\r\n+      } catch (error) {\r\n+        console.error('Profile upload failed:', error);\r\n+      }\r\n+    }\r\n+\r\n+    // Handle item images\r\n+    if (Array.isArray(data.items)) {\r\n+      updates.items = await Promise.all(data.items.map(async (item) => {\r\n+        const processedItem = {\r\n+          id: item.id,\r\n+          name: item.name || '',\r\n+          price: item.price || '',\r\n+          description: item.description || '',\r\n+          currentImageIndex: item.currentImageIndex || 0,\r\n+          images: []\r\n+        };\r\n+\r\n+        if (Array.isArray(item.images)) {\r\n+          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\r\n+            if (!(image?.file instanceof File)) return null;\r\n+            \r\n+            try {\r\n+              const metadata = {\r\n+                contentType: image.type || 'image/jpeg'\r\n+              };\r\n+              const imageRef = ref(storage, `shops/${userId}/items/${item.id}/image-${index}-${Date.now()}`);\r\n+              const snapshot = await uploadBytes(imageRef, image.file, metadata);\r\n+              return await getDownloadURL(snapshot.ref);\r\n+            } catch (error) {\r\n+              console.error(`Failed to upload image ${index}:`, error);\r\n+              return null;\r\n+            }\r\n+          }));\r\n+          \r\n+          processedItem.images = imageUrls.filter(Boolean);\r\n+        }\r\n+\r\n+        return processedItem;\r\n+      }));\r\n+    }\r\n+\r\n+    // Clean updates before saving to Firestore\r\n+    const cleanUpdates = cleanDataForFirestore({\r\n+      ...updates,\r\n+      updatedAt: new Date().toISOString()\r\n+    });\r\n+\r\n+    // Update Firestore with clean data\r\n+    if (Object.keys(cleanUpdates).length > 0) {\r\n+      await updateDoc(shopRef, cleanUpdates);\r\n+    }\r\n+\r\n+    return true;\r\n+  } catch (error) {\r\n+    console.error('Error uploading images:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+export const getShopData = async (userId) => {\r\n+  try {\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    const shopSnap = await getDoc(shopRef);\r\n+    \r\n+    if (shopSnap.exists()) {\r\n+      return shopSnap.data();\r\n+    }\r\n+    \r\n+    return null;\r\n+  } catch (error) {\r\n+    console.error('Error getting shop data:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Updated updateShopData to use batch operations\r\n+export const updateShopData = async (userId, updateData) => {\r\n+  try {\r\n+    // Use the new batch update function\r\n+    return await batchUpdateShopData(userId, updateData);\r\n+  } catch (error) {\r\n+    console.error('Error updating shop data:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Optimized single field update (for real-time updates like view counts)\r\n+export const updateSingleField = async (userId, field, value) => {\r\n+  try {\r\n+    const shopRef = doc(db, 'shops', userId);\r\n+    await updateDoc(shopRef, {\r\n+      [field]: value,\r\n+      updatedAt: new Date().toISOString()\r\n+    });\r\n+    return true;\r\n+  } catch (error) {\r\n+    console.error(`Error updating field ${field}:`, error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Bulk operations for multiple shops (admin use)\r\n+export const bulkUpdateShops = async (updates) => {\r\n+  try {\r\n+    const batch = writeBatch(db);\r\n+    \r\n+    updates.forEach(({ userId, data }) => {\r\n+      const shopRef = doc(db, 'shops', userId);\r\n+      const cleanedData = cleanDataForFirestore({\r\n+        ...data,\r\n+        updatedAt: new Date().toISOString()\r\n+      });\r\n+      batch.update(shopRef, cleanedData);\r\n+    });\r\n+    \r\n+    await batch.commit();\r\n+    console.log(`Bulk update completed for ${updates.length} shops`);\r\n+    return true;\r\n+  } catch (error) {\r\n+    console.error('Error in bulk update:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Search Operations\r\n+export const searchShops = async (searchTerm) => {\r\n+  try {\r\n+    const shopsRef = collection(db, 'shops');\r\n+    const q = query(\r\n+      shopsRef,\r\n+      where('status', '==', 'active'),\r\n+      where('searchTerms', 'array-contains', searchTerm.toLowerCase())\r\n+    );\r\n+    \r\n+    const querySnapshot = await getDocs(q);\r\n+    return querySnapshot.docs.map(doc => ({\r\n+      id: doc.id,\r\n+      ...doc.data()\r\n+    }));\r\n+  } catch (error) {\r\n+    console.error('Error searching shops:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Helper function to create search terms for better search functionality\r\n+export const generateSearchTerms = (shopData) => {\r\n+  const terms = new Set();\r\n+  \r\n+  // Add shop name terms\r\n+  if (shopData.shopName) {\r\n+    const words = shopData.shopName.toLowerCase().split(' ');\r\n+    words.forEach(word => terms.add(word));\r\n+  }\r\n+\r\n+  // Add item names and tags\r\n+  if (shopData.items) {\r\n+    shopData.items.forEach(item => {\r\n+      if (item.name) {\r\n+        const words = item.name.toLowerCase().split(' ');\r\n+        words.forEach(word => terms.add(word));\r\n+      }\r\n+      if (item.tags) {\r\n+        item.tags.forEach(tag => terms.add(tag.toLowerCase()));\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  return Array.from(terms);\r\n+};\r\n+\r\n+// Analytics and performance tracking\r\n+export const trackShopAnalytics = async (userId, action, metadata = {}) => {\r\n+  try {\r\n+    const analyticsRef = doc(db, 'analytics', `${userId}_${Date.now()}`);\r\n+    await setDoc(analyticsRef, {\r\n+      shopId: userId,\r\n+      action,\r\n+      metadata,\r\n+      timestamp: new Date().toISOString()\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error tracking analytics:', error);\r\n+    // Don't throw - analytics shouldn't break the main flow\r\n+  }\r\n+};\r\n+\r\n+// Cleanup functions for removing old data\r\n+export const cleanupOldImages = async (userId) => {\r\n+  try {\r\n+    // This would implement logic to remove unused images from storage\r\n+    // Implementation depends on your storage organization\r\n+    console.log(`Cleanup initiated for user ${userId}`);\r\n+    return true;\r\n+  } catch (error) {\r\n+    console.error('Error during cleanup:', error);\r\n+    throw error;\r\n+  }\r\n+};\r\n+\r\n+// Export all functions\r\n+export default {\r\n+  getFeaturedItems,\r\n+  checkExistingShop,\r\n+  saveInitialShop,\r\n+  saveShopData,\r\n+  batchUpdateShopData,\r\n+  uploadShopImages,\r\n+  getShopData,\r\n+  updateShopData,\r\n+  updateSingleField,\r\n+  bulkUpdateShops,\r\n+  searchShops,\r\n+  generateSearchTerms,\r\n+  trackShopAnalytics,\r\n+  cleanupOldImages\r\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1738038751717,
            "name": "Commit-0",
            "content": "// src/firebase/firebaseService.js\n\nimport { \n  doc, \n  setDoc, \n  getDoc, \n  updateDoc,\n  collection,\n  query,\n  where,\n  getDocs\n} from 'firebase/firestore';\nimport { \n  ref, \n  uploadBytes, \n  getDownloadURL \n} from 'firebase/storage';\nimport { db, storage } from './config';\n\n// Shop Operations\n// Also update the saveShopData function to log the structured data\n// Update the saveShopData function in firebaseService.js\n\n// Update the saveShopData function in firebaseService.js\n// src/firebase/firebaseService.js\n\n// In firebaseService.js\n\nexport const getFeaturedItems = async (limit = 6) => {\n  try {\n    // Get all shop documents\n    const shopsRef = collection(db, 'shops');\n    const shopsSnapshot = await getDocs(shopsRef);\n    \n    // Collect all items from all shops\n    let allItems = [];\n    shopsSnapshot.forEach(doc => {\n      const shop = doc.data();\n      const shopId = doc.id;\n      \n      // Only add items that have images and required fields\n      const validItems = (shop.items || []).filter(item => \n        item.name && \n        item.price && \n        item.images && \n        item.images.length > 0\n      ).map(item => ({\n        ...item,\n        shopId,\n        shopName: shop.name,\n        shopTheme: shop.theme\n      }));\n      \n      allItems = [...allItems, ...validItems];\n    });\n    \n    // Sort by newest first (assuming items have a timestamp)\n    allItems.sort((a, b) => b.createdAt - a.createdAt);\n    \n    // Return limited number of items\n    return allItems.slice(0, limit);\n  } catch (error) {\n    console.error('Error fetching featured items:', error);\n    return [];\n  }\n};\n\n// Add this utility function to clean data before saving to Firestore\nconst cleanDataForFirestore = (data) => {\n  if (!data) return data;\n  \n  if (Array.isArray(data)) {\n    return data.map(item => cleanDataForFirestore(item));\n  }\n  \n  if (typeof data === 'object' && !(data instanceof Date)) {\n    const cleanedData = {};\n    for (const [key, value] of Object.entries(data)) {\n      // Skip file objects and null/undefined values\n      if (value instanceof File || value === null || value === undefined) {\n        continue;\n      }\n      cleanedData[key] = cleanDataForFirestore(value);\n    }\n    return cleanedData;\n  }\n  \n  return data;\n};\n\n// Add this helper function at the top\nconst uploadImageWithCORS = async (file, path) => {\n  if (!file) return null;\n  \n  const metadata = {\n    contentType: file.type || 'image/jpeg',\n    cacheControl: 'public,max-age=3600',\n    customMetadata: {\n      'Access-Control-Allow-Origin': '*'\n    }\n  };\n\n  try {\n    // Create a blob with CORS headers\n    const blob = new Blob([file], { type: file.type });\n    const imageRef = ref(storage, path);\n    const snapshot = await uploadBytes(imageRef, blob, metadata);\n    return await getDownloadURL(snapshot.ref);\n  } catch (error) {\n    console.error('Error uploading image:', error);\n    return null;\n  }\n};\n\nexport const saveShopData = async (userId, data) => {\n  try {\n    console.log('Starting shop data save:', { userId, data });\n    \n    // Clean data before saving to Firestore\n    let shopData = {\n      name: data.name || '',\n      description: data.description || '',\n      theme: cleanDataForFirestore(data.theme) || {},\n      layout: cleanDataForFirestore(data.layout) || {},\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      userId: userId,\n      items: data.items?.map(item => ({\n        id: item.id || Date.now().toString(),\n        name: item.name || '',\n        price: item.price || '',\n        description: item.description || '',\n        currentImageIndex: item.currentImageIndex || 0,\n        images: [] // Initialize empty, will be updated after upload\n      })) || [],\n      profile: null // Initialize as null, will be updated after upload\n    };\n\n    // Save initial clean data\n    const shopRef = doc(db, 'shops', userId);\n    await setDoc(shopRef, shopData);\n\n    // Now try image uploads with new CORS configuration\n    if (data.profile?.file) {\n      try {\n        const profileUrl = await uploadImageWithCORS(\n          data.profile.file,\n          `shops/${userId}/profile/profile-${Date.now()}`\n        );\n        \n        if (profileUrl) {\n          shopData.profile = profileUrl;\n          await updateDoc(shopRef, {\n            profile: profileUrl,\n            updatedAt: new Date().toISOString()\n          });\n        }\n      } catch (profileError) {\n        console.error('Profile upload failed:', profileError);\n      }\n    }\n\n    // Try uploading item images\n    if (Array.isArray(data.items)) {\n      const processedItems = await Promise.all(data.items.map(async (item) => {\n        const processedItem = {\n          id: item.id || Date.now().toString(),\n          name: item.name || '',\n          price: item.price || '',\n          description: item.description || '',\n          currentImageIndex: item.currentImageIndex || 0,\n          images: []\n        };\n    \n        if (Array.isArray(item.images)) {\n          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n            if (!image?.file) return null;\n            \n            return await uploadImageWithCORS(\n              image.file,\n              `shops/${userId}/items/${processedItem.id}/image-${index}-${Date.now()}`\n            );\n          }));\n          \n          processedItem.images = imageUrls.filter(Boolean);\n        }\n    \n        return processedItem;\n      }));\n    \n      shopData.items = processedItems;\n    \n      // Update items in Firestore\n      await updateDoc(shopRef, {\n        items: processedItems,\n        updatedAt: new Date().toISOString()\n      });\n    }\n\n    console.log('Shop data saved successfully:', shopData);\n    return shopData;\n\n  } catch (err) {\n    console.error('Error in saveShopData:', err);\n    throw err;\n  }\n};\n\n// Add new function for image uploads\nexport const uploadShopImages = async (userId, data) => {\n  try {\n    const shopRef = doc(db, 'shops', userId);\n    let updates = {};\n\n    // Handle profile image\n    if (data.profile?.file instanceof File) {\n      try {\n        const metadata = {\n          contentType: data.profile.type || 'image/jpeg'\n        };\n        const profileRef = ref(storage, `shops/${userId}/profile/profile-${Date.now()}`);\n        const profileSnapshot = await uploadBytes(profileRef, data.profile.file, metadata);\n        updates.profile = await getDownloadURL(profileSnapshot.ref);\n      } catch (error) {\n        console.error('Profile upload failed:', error);\n      }\n    }\n\n    // Handle item images\n    if (Array.isArray(data.items)) {\n      updates.items = await Promise.all(data.items.map(async (item) => {\n        const processedItem = {\n          id: item.id,\n          name: item.name || '',\n          price: item.price || '',\n          description: item.description || '',\n          currentImageIndex: item.currentImageIndex || 0,\n          images: []\n        };\n\n        if (Array.isArray(item.images)) {\n          const imageUrls = await Promise.all(item.images.map(async (image, index) => {\n            if (!(image?.file instanceof File)) return null;\n            \n            try {\n              const metadata = {\n                contentType: image.type || 'image/jpeg'\n              };\n              const imageRef = ref(storage, `shops/${userId}/items/${item.id}/image-${index}-${Date.now()}`);\n              const snapshot = await uploadBytes(imageRef, image.file, metadata);\n              return await getDownloadURL(snapshot.ref);\n            } catch (error) {\n              console.error(`Failed to upload image ${index}:`, error);\n              return null;\n            }\n          }));\n          \n          processedItem.images = imageUrls.filter(Boolean);\n        }\n\n        return processedItem;\n      }));\n    }\n\n    // Clean updates before saving to Firestore\n    const cleanUpdates = cleanDataForFirestore({\n      ...updates,\n      updatedAt: new Date().toISOString()\n    });\n\n    // Update Firestore with clean data\n    if (Object.keys(cleanUpdates).length > 0) {\n      await updateDoc(shopRef, cleanUpdates);\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error uploading images:', error);\n    throw error;\n  }\n};\n\nexport const getShopData = async (userId) => {\n  try {\n    const shopRef = doc(db, 'shops', userId);\n    const shopSnap = await getDoc(shopRef);\n    \n    if (shopSnap.exists()) {\n      return shopSnap.data();\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Error getting shop data:', error);\n    throw error;\n  }\n};\n\nexport const updateShopData = async (userId, updateData) => {\n  try {\n    const shopRef = doc(db, 'shops', userId);\n    \n    // Handle any new image uploads\n    let updates = { ...updateData };\n    \n    if (updateData.profile?.file) {\n      const profileRef = ref(storage, `shops/${userId}/profile`);\n      await uploadBytes(profileRef, updateData.profile.file);\n      updates.profileImage = await getDownloadURL(profileRef);\n    }\n\n    if (updateData.items) {\n      updates.items = await Promise.all(updateData.items.map(async (item, index) => {\n        const processedItem = { ...item };\n        if (item.images) {\n          const processedImages = await Promise.all(item.images.map(async (image, imgIndex) => {\n            if (image?.file) {\n              const imageRef = ref(storage, `shops/${userId}/items/${index}/${imgIndex}`);\n              await uploadBytes(imageRef, image.file);\n              return await getDownloadURL(imageRef);\n            }\n            return image; // Keep existing image URL if no new file\n          }));\n          processedItem.images = processedImages;\n        }\n        return processedItem;\n      }));\n    }\n\n    await updateDoc(shopRef, {\n      ...updates,\n      updatedAt: new Date().toISOString()\n    });\n\n    return true;\n  } catch (error) {\n    console.error('Error updating shop data:', error);\n    throw error;\n  }\n};\n\n// Search Operations\nexport const searchShops = async (searchTerm) => {\n  try {\n    const shopsRef = collection(db, 'shops');\n    const q = query(\n      shopsRef,\n      where('status', '==', 'active'),\n      where('searchTerms', 'array-contains', searchTerm.toLowerCase())\n    );\n    \n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error searching shops:', error);\n    throw error;\n  }\n};\n\n// Helper function to create search terms for better search functionality\nexport const generateSearchTerms = (shopData) => {\n  const terms = new Set();\n  \n  // Add shop name terms\n  if (shopData.shopName) {\n    const words = shopData.shopName.toLowerCase().split(' ');\n    words.forEach(word => terms.add(word));\n  }\n\n  // Add item names and tags\n  if (shopData.items) {\n    shopData.items.forEach(item => {\n      if (item.name) {\n        const words = item.name.toLowerCase().split(' ');\n        words.forEach(word => terms.add(word));\n      }\n      if (item.tags) {\n        item.tags.forEach(tag => terms.add(tag.toLowerCase()));\n      }\n    });\n  }\n\n  return Array.from(terms);\n};\n"
        }
    ]
}